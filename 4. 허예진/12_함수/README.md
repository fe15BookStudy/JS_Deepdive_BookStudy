# 12. 함수

## 함수란 ?

일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

수학의 함수와 같이 입력을 받아서 출력을 내보낸다.  
함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력을 **인수**, 출력을 **반환값**이라 한다.

```js
// 함수 정의
function add(x, y) {   // 함수이름(매개변수)
  return x + y; // 반환값
}

// 함수 호출
add(2, 5); // 2와 5는 인수
```

함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고, 실행결과, 즉 반환값을 반환한다.

```js
let result = add(2, 5);

console.log(result); // 7
```

## 함수를 사용하는 이유

동일한 작업을 반복적으로 수행해야 할 때 코드를 중복해서 여러번 작성하는 것이 아니라 미리 정의된 함수를 재사용할 수 있다.  
➡️ 유지보수의 편의성을 높이고 코드의 신뢰성을 높이는 효과가 있다.

## 함수 리터럴

리터럴이란 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식을 말한다.
함수 리터럴은 function 키워드, 함수이름, 매개 변수 목록, 함수 몸체로 구성된다.

|   구성요소   | 설명                                                                                                                          |
| :-----------: | :---------------------------------------------------------------------------------------------------------------------------- |
|   함수 이름   | 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야한다. <br/> 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. <br/> 함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명함수라 한다.|
| 매개변수 목록 | 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. <br/> 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다. <br/> 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.                                                                                                                          |
|   함수 몸체   | 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블럭이다. <br/> 함수 몸체는 함수 호출에 의해 실행된다.                                                                                                                          |

함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다. 즉, 함수는 객체다.  
일반 객체는 호출할 수 없지만 함수는 호출할 수 있고, 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.  
함수가 객체라는 사실은 자바스크립트만의 중요한 특징이다.

## 함수 정의

함수를 정의하는 방법은 4가지가 있다.

1. 함수 선언문
```js
function add(x,y) {
  return x + y;
}
```
2. 함수 표현식
```js
let add = function(x, y) {
  return x + y;
}
```
3.Function 생성자 함수
```js
let add = new Function('x', 'y', 'return x + y');
```
4. 화살표 함수(ES6)
```js
let add = (x, y) => x + y;
```

### 함수 선언문
함수 선언문은 함수 이름을 생략할 수 없다.  
```js
// SyntaxError
function (x, y) {  
  return x + y;
}
```

그룹연산자() 내에 있는 함수 리터럴은 함수 선언문으로 해석되지 않고 함수 리터럴 표현식으로 해석된다.
```js
// ReferenceError
(function bar() {  
  console.log('bar');
})
```

아래 예제를 보면
```js
function foo() {
  console.log('foo');
}
```
식별자를 선언한 적 없어도 함수 선언문에서는 함수 이름과 동일한 이름의 식별자를 자동으로 스코프에 등록하기 때문에 외부에서 그 이름을 접근이 가능하다.
```js
const bar = function bat() { console.log('bar'); };
bar();  // 실행됨
bat();  // ❌ ReferenceError (외부에서는 모름)
```
함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

### 함수 생성 시점과 호이스팅
함수 선언문으로 정의한 함수는 이전에 호출할 수 있다.  
```js
console.log(add(2, 5));
// 함수 선언문
function add (x, y) {  
  return x + y;
}
```
가능 !!!


함수 표현식으로 정의한 함수는 함수표현식 이전에 호출할 수 없다.  
```js
console.log(add(2, 5));
// 함수 선언문
let add = function (x, y) {  
  return x + y;
}
```
✖️✖️불가능 !!!✖️✖️


### Function 생성자 함수
```js
let add = new Function('x', 'y', 'return x + y');

console.log(add(2,5)); // 7
```
function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.


### 화살표 함수
화살표 함수는 ES6에서 도입되었다.
```js
let add = (x, y) => x + y;
```
화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고 프로토타입 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

## 함수 호출
함수를 호출할 때에는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.  
0개 이상의 인수를 쉼표로 구분해서 나열한다.

### 매개변수와 인수
```js
// 함수 선언문
function add (x, y) {  
  return x + y;
}

// 함수 호출
let result = add(1,2);
```
매개변수의 개수보다 인수의 개수가 부족하면 값은 undefined로 나온다.
매개변수의 개수보다 인수의 개수가 더 많은 경우 초과된 인수는 무시된다.

```js
// 함수 선언문
function add (x, y) {  
  return x + y;
}

// 함수 호출
console.log(add(2)); // 인수 부족 : 2 + undefined => NaN
console.log(add(2,5,7)); // 인수 초과 : 7 (2 + 5)
```

### 인수 확인
```js
function add(x, y) {
  return x + y;
}

console.log(add(2)); // NaN
console.log(add("a", "b")); // 'ab'
```
위 코드는 자바스크립트 문법상 어떠한 문제도 없지만 적절한 인수를 전달하였는지 확인할 필요가 있다.

```js
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add(0)); // 0
```
ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

### 매개변수의 최대 개수
이상적인 매개변수 개수는 0개 이며 적을수록 좋다.
이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 한다.


### 반환문
```js
function multiply(x, y) {
  return x * y; // 반환문
}

let result = multiply(3, 5);
console.log(result); // 15
```
함수는 return 키워드를 사용해 자바스크립트에서 사용 가느한 모든 값을 반환할 수 있다.

```js
function multiply(x, y) {
  return x * y; // 반환문
  console.log("실행되지 않는다.");
}

let result = multiply(3, 5);
console.log(result); // 15
```
반환문은 함수의 실행을 중단하기 때문에 다른 문지 존재한다면 그 문은 실행되지 않는다.

반환문을 생략하면 암묵적으로 undefined가 반환된다.

## 참조에 의한 전달과 외부 상태의 변경
원시값: 값에 의한 전달  
객체: 참조에 의한 전달  
매개변수에서도 타입에 따라 값에 의한 전달, 참조에 의한 전달방식을 그대로 따른다.

## 다양한 함수의 형태

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라 한다.  
즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없다.
```js
// 익명 즉시 실행 함수
(function () {
  let a = 3;
  let b = 5;
  return a * b;
}());

// 기명 즉시 실행 함수
(function foo() {
  let a = 3;
  let b = 5;
  return a * b;
}());

foo(); // ReferenceEffor: foo is not defined
```

### 재귀 함수
함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다.  
재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.

```js
function countdwon(n) {
  if (n < 0) return;
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);
```
반복문 없이 반복 처리를 구현할 수 있다.  
재귀 호출을 멈출 수 있는 탈출조건을 반드시 만들어야한다.

### 중첩 함수
함수 내부에 정의된 함수를 중첩함수 또는 내부함수라고 한다.  
중첩 함수는 외부 함수 내부에서만 호출할 수 있다.
```js
function outer(){
  let x=1;

  // 중첩 함수
  function inner(){
    let y=2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x+y);
  }
  inner();
}
outer();
```

### 콜백 함수
```js
function repeat(n, callback) {
  for (let i = 0; i < n; i++) {
    callback(i); // 여기서 전달받은 함수를 호출
  }
}

// 사용 예시 1: 출력
repeat(5, console.log);
// 0 1 2 3 4

// 사용 예시 2: 제곱값 출력
repeat(5, function (x) {
  console.log(x * x);
});
// 0 1 4 9 16
```
여기서 `console.log`나 `function(x) { ... }`가 콜백 함수

### 순수 함수와 비순수 함수
- 순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수
```js
function increase(n) {
  return ++n;
}
```
* 동일한 입력 -> 동일한 출력
* 외부 상태에 의존하지 않는다.


- 비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수
```js
let count = 0;

function increase() {
  return ++count;
}

increase();
console.log(count); // 1

increase();
console.log(count); // 2
```
* 호출할 때마다 값이 달라진다.
* 외부 상태에 의존하거나 변경한다.
* 전역변수 count 라는 외부 상태를 변경한다.