# 모던 자바스크립트 Deep Dive

## 12장 함수

## 함수란?

프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의 한 것이다. 프로그래밍 언어의 함수도 입력을 받아서 출력을 내보낸다. 입력을 전달받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라 한다.

## 함수를 사용하는 이유

함수를 사용하지 않고 같은 코드를 중복해서 사용하면 그 코드를 수정할 때 많은 시간이 들고 실수할 가능성이 높아진다. 따라서 코드의 중복을 억제해서 재사용성을 높이고 유지보수의 편의성도 높여서 코드의 신뢰성이 올라간다.

## 함수 리터럴

자바스크립트의 함수는 객체이다. 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리털로 생성이 가능하다.

함수 리터럴의 구성에는 함수 이름, 매개변수 목록, 함수 몸체가있다.

- 함수이름

  - 함수이름은 식별자이므로 네이밍규칙을 지켜야함.
  - 생략가능
  - 몸체 내에서만 참조 가능한 식별자임.

- 매개변수 목록

  - 변수와 동일하게 취급해서 매개변수도 네이밍 규칙 지켜야함.
  - 순서에 의미가 있음.

- 함수 몸체
  - 호출에 의해 실행함.

## 함수 정의

함수 정의 방식에는 힘수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수 가있다.

### 함수 선언문

함수 선언문을 사용하는 방식은 다음과 같다.

```jsx
function add(x, y) {
  return x + y;
}
```

함수 표현식은 이름을 생략할 수 있지만 함수 선언문은 생략할 수 없다.

```jsx
function (x, y) {
  return x + y; // 에러 발생함
}
```

함수 선언문은 표현식이 아닌 문이다. 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행하면 완료값 undefined가 출력된다. 함수 선언문이 만약 표현식인 문이라면 완료값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 한다. <br>
표현식이 아닌 문은 변수에 할당할 수 없다. 함수 선언문도 표현식이 아니므로 변수에 할당할 수 없다. 근데 다음 예제를 보면 할당되는 것 처럼 보인다.

```jsx
var add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5)); //7
```

그 이유는 자바스크립트 엔진이 문맥에 따라 **함수 리터럴을 표현식이 아닌 문인 함수 선언문**으로 해석하는 경우와 **표현식인 문인 함수 리터럴 표현식**으로 해석하는 경우가 있기 때문이다. {}은 블록문일 수도 있고 객체 리터럴일 수도 있다.

 자바스크립트 엔진은 {}를 코드 블록으로 해석 할까 객체 리터럴로 해석 할까? 
 
 {}가 단독으로 존재 하면 자바스크립트 엔진은 블록문으로 해석 한다. 하지만 값으로 평가 되어야 할 문맥에서는 피연산자로 사용 되면 자바스크립트 엔진을 객체 리터럴로 해석 한다. 따라서 코드의 문맥에 따라 해석이 달라질 수 있다. 
 
 자바스크립트 엔진은 **함수 이름이 있는 함수 리터럴을 단독으로 사용 하면 함수 선언문**으로 해석하고 **값으로 평가 되어야 하는 문맥 예를 들어 함수리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴을 표현식**으로 해석 한다.

```jsx
var add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5)); //7
```
함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자 호출한다. 즉, 함수 선언문으로 생성한 함수를 호출한 것은 함수 이름 add가아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add 인것이다. 둘의 이름이 일치해서 함수이름으로 호출되는 것처럼 보이지만 사실은 식별자로 호출된 것이다!

### 함수 표현식

자바스크립트 함수는 객체타입의 값이다. 자바스크립트의 함수는 값처럼 변수에 할당할 수 도도있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 개체를 **일급 객체**라 한다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 따라서 함수 객체를 변수에 할당 할 수 있다. 아래는 함수 편식을 나타내는코드 이다.

```jsx
var add = function (x, y) {
  return x + y;
};
console.log(add(2, 5));
```

- 함수 리터럴의 함수 이름은 생략 할 수 있다.
- 함수 호출 할 때는 객체를 가리키는 식별자를 사용해야 한다.

함수 선언문과 함수 표현 식은 비슷하게 동작 하는 것처럼 보이지만 미묘한 차이가 있다. 함수 선언문으로 정의 한 함수는 함수 선언문 이전에 호출 할 수 있다. 그러나 함수 표현 식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

이는 함수 선언문으로 정의 한 함수와 함수 표현 식으로 정의 한 함수의 생성 시점이 다르기 때문이다. 모든 선언문이 그렇듯 함수 선언문도 런타임 이전에 엔진에 먼저 실행 된다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작 하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.

변수 호이스팅과 함수호이스팅은 미묘한 차이가 있으므로 주의해야 한다.
함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다. 함수 표현 식으로 함수를 정의 하면 함수호이스팅이 발생 하는 것이 아니라 변수 호이스팅이 발생한다. 함수 표현식 이전에 함수를 참조 하면 undefined로 평가 된다. 따라서 이때 함수를 호출 하면 undefined를 호출 하는 것과 마찬가지이므로 타입 에러가 발생 한다.

### Function 생성자 함수

```jsx
var add = new Function("x", "y", "return x+y");

console.log(add(2, 5));
```

Function 생성자 함수로 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

### 화살표 함수

```jsx
const add = (x, y) => x + y;
console.log(add(2, 5));
```

### 함수호출

함수를 호출하기 위해 매개변수를 통해 인수를 전달한다. 인수는 함수를 호출할 때 지정하면 개수와 타입에 제한이 없다.

매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다. 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 일반적으로는 매개변수의 개수만큼 인수를 전달하지만 그렇지 않아도 에러가 발생하지 않는다. 인수가 할당되지 않은 매개변수의 값은 undefined이다.

```jsx
function add(x, y) {
  return x + y;
}
console.log(add(2)); //NaN 오류가발생하지않고 NaN이 나옴
```

오류가발생하지않고 NaN이 나옴

```jsx
function add(x, y) {
  return x + y;
}
console.log(add(2, 5, 10)); // 7
```

초과된 인수는 버려지지 않고 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

```jsx
function add(x, y) {
  console.log(arguments);
  // Arguments(3)[2, 5, 10 ......]
  return x + y;
}
add(2, 5, 10);
```

### 인수 확인

```jsx
function add(x, y) {
  return x + y;
}
console.log(add(2)); //NaN
console.log(add("a", "b")); // 'ab'
```

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 동적타입 언어다. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

따라서 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.

```jsx
function add(x, y) {
  if (typeof x !== "number" || typeof y !== "number") {
    throw new TypeError("인수는 모두 숫자 값이어야 합니다.");
  }
  return x + y;
}
console.log(add(2)); //'인수는 모두 숫자 값이어야 합니다.'
console.log(add("a", "b")); // '인수는 모두 숫자 값이어야 합니다.'
```

또는 인수가 전달되지 않은 경우 단축평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.

```jsx
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}
console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0

//ES6
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}
console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

### 매개변수의 최대개수

명시적으로 제한하고 있지 않다. 하지만 물리적인 한계는 있으므로 자바스크립트 엔진마다 매개변수의 최대개수에 대한 제한이 있겠지만 충분히 많은 매개변수를 지정할 수 있다.

매개변수는 순서에 의미가 있어 매개변수가 많아지게 되면 함수를 호출할 때 실수가 일어날 확률이 늘어나고 오류가 날 가능성이 높아져 가급적이면 3개이상을 넘지 않는 것을 권장한다.

### 반환문

함수는 return 키워드가 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

반환문은 두가지 역할이 있는데 첫째는 함수의 실행을 중단하고 함수 몸체를 빠져나가는 것이고, 둘째는 return뒤에 오는 표현식을 평가해 반환하는 것이다. 명시적으로 지정하지 않으면 undefined가 반환된다.

```jsx
//첫번째
function multifly(x, y) {
  return x * y;
  console.log("실행되지 않는다."); //무시됨
}
console.log(multifly(3, 5)); //15

//두번째
function foo() {
  return;
}
console.log(foo()); //undefined
```

## 참조에 의한 전달과 외부 상태의 변경

```jsx
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "kim";
}

var num = 100;
var person = { name: "Lee" };

console.log(num); // 100
console.log(person); //{name:'Lee'}

changeVal(num, person);

console.log(num); // 100 :변경이 안된다.
console.log(person); //{name:'kim'} 변경된다.
```

원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에 값이 변경해도 원본은 훼손되지 않는다. 하지만 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손된다.

## 다양한 함수의 형태

### 즉시 실행함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라 한다. 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없다.

```jsx
var res = (function foo() {
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(res); //15

foo(); //에러
```
### 재귀함수
함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.
```jsx
function countdown(n){
  for(var i=n;i>=0;i++) console.log(i);
}
countdown(10);

// 재귀함수로 바꾸면
function countdown(n){
  if(n<0) return;
  console.log(n);
  countdown(n-1); //재귀 호출
}
countdown(10);
```
이처럼 자기자신을 호출하는 함수를 쓰면 반복되는 부분을 반복문 없이 구현할 수 있다. 재귀함수는 자신을 무한히 호출하므로 반드시 탈출조건이 있어야 한다!

### 중첩 함수
함수 내부에 정의된 함수를 중첩 함수또 는 내부 함수라한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수라 부른다. 중첩함수는 외부함수 내에서만 호출할 수 있다. 일반적으로 중첩함수는 외부함수를 돕는 헬퍼 함수의 역할을 한다.
```jsx
function outer(){
  var x=1;

  function inner(){
    var y=2;
    console.log(x+y);
  }
  inner();
}
outer();
```
### 콜백 함수
함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다. 고차함수는 콜백함수를 자신의 일부분으로 합성한다. 

고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 다시말해, 콜백 함수는 고차함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.



### 순수 함수와 비순수 함수
함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수를 비순수 함수 라고한다.
```jsx
var count=0;

function increase(n)
{
  return ++n;
}

increase(count);


console.log(count); //0

count=increase(count); 

// 순수함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
console.log(count); //1

/* ----------------------------------------------------------*/

var count=0;

// 비순수 함수
function increase()
{
  return ++count; //외부상태에 의존하며 외부 상태를 변경한다.
}

increase();
console.log(count); //1

increase();
console.log(count); //2
```

함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이다.