# 12. 함수

### 함수란 ?

- 프로그래밍 언어의 함수는 **일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의** 한 것

이 함수도 수학적 함수처럼 입력을 받아 출력을 내보내는데, 함수 내부로 입력을 전달받는 변수를 `매개변수 (parameter)`, 입력을 `인수 (argument)` , 출력을 `반환값(return value)`이라 한다.

또한 함수는 값이며 , 여러 개 존재할 수 있으며 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.

함수는 함수 정의 (function definition)를 통해 생성한다.

다음은 함수 선언문을 통해 함수를 정의 한 예다.

```JavaScript
//함수 정의
function add(x,y) {
    return x + y;
}
```

<br>

함수 정의 만으로 함수가 실행 되지는 않는다. 인수(argument)를 매개변수를 통해 함수에 전달하며 함수의 실행을 명시적으로 지시하는 **함수 호출 ( function call/ invoke )** 이 필요하다.

```JavaScript
//함수 호출
var result = add(2,5);

//함수 add에 인수 2,5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); //7
```

<br>

---

### 함수 리터럴

- 자바스크립트에서 함수는 **객체 타입** 의 값인데, 따라서 함수도 함수 리터럴로 생성 할 수 있다. 함수 리터럴은 `function 키워드` , `함수 이름`, `매개 변수 목록` , `함수 몸체`로 구성된다.

<br>
<p align="center">
<img src="./12_function.jpg" 
    width="500px;"
   </p>

<br>

```JavaScript
//변수에 함수 리터럴을 할당
var f = function add(x,y) {
    return x + y ;
};
```

함수 리터럴의 구성 요소는 다음과 같다.

```
1. 함수 이름

 - 함수 이름은 식별자 - 네이밍 규칙 준수 해야함

 - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자

 - 함수 이름은 생략 가능
```

```
2. 매개변수 목록

- 0 개 이상의 매배견수를 소괄호로 감싸고 쉼표로 구분

- 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당. 즉, 매개변수 목록은 순서에 의미가 있음

- 매개변수는 함수 몸체 내에서 변수와 동일하게 취급. 매개변수도 식별자 네이밍 규칙 준수 해야
```

```
3. 함수 몸체

- 함수가 호출 되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록

- 함수 호출에 의해 실행
```

함수는 객체지만 일반 객체와는 다르다. **일반 객체는 호출할 수 없으나 함수는 호출 가능하다.**

---

### 함수 정의

#### 1. 함수 선언문

함수 선언문을 사용해 함수를 선언하는 방식은 다음과 같다.

<br>

```JavaScript
//함수 선언문
fuction add(x,y) {
    return x + y ;
}

// 함수 참조
//console.dir 은 console.log와는 달리 함수 객체의 프로퍼티 까지 출력한다.
//단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // f add (x,y)

//함수 호출
console.log(add(2,5)); //7
```

함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없다.**

**함수 선언문은 표현식이 아닌 문이다.** 따라서 크롬 개발자 도구의 콘솔에서 함수 선언문을 실행한다면 완료 값 undefined 가 출력될 것이다.

앞서 5.6 절에서 살펴 보았듯이, 표현식이 아닌 문은 변수에 할당할 수 없다.

```JavaScript
///함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
//하지만 함수 선언문이 변수에 할당 되는 것처럼 보인다.
var add = function add(x,y) {
    return x+y ;

};

//함수 호출
console.log (add(2,5)); //7
```

그러나 위 예시 코드를 보면 함수 선언문이 변수에 할당 되는 것처럼 보인다. 이렇게 동작하는 이유는 자바스크립트 엔진이 코드의 **문맥에 따라** 동일한 함수 리터럴을 `표현식이 아닌 문인 함수 선언문`으로 해석하는 경우와 `표현식인 문인 함수 리터럴 표현식`으로 해석하는 경우가 있기 때문이다.

함수 선언식은 함수 이름을 생략할 수 없다는 점을 제외한다면 리터럴과 형태가 동일하다. 이때문에 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 존재한다.

예를들면, { } 은 블록문일 수도 있고, 객체 리터럴일 수도 있으므로 { }은 중의적 표현이다. 자바스크립트 엔진은 이러한 { }을 문맥에 따라 다르게 해석한다.

기명 함수 리터럴도 중의적인 코드므로 `코드의 문맥에 따라 해석이 달라질 수 있다.` 이때 함수 선언문이든 함수 리터럴 표현식이든 함수가 생성되는 것은 동일하나 함수를 생성하는 내부 동작에 차이가 있다.

```JavaScript
//기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo');}
foo(); //foo

//함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
//함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {console.log('bar';)});
bar(); //ReFerenceError: bar is not defined
```

위 예시코드에서 단독으로 사용된 함수 리터럴(foo)은 함수 선언문으로 해석되었는데, 그룹 연산자 ( ) 내에 있는 함수 리터럴 (bar) 은 함수 리터럴 표현식으로 해석 되었다. 그룹 연산자이 피연산자는 값으로 평가될 수 있는 표현식이어야 하므로 , `표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다.`

함수 선언문과 함수 리터럴 표현식은 함수 객체를 생성한다는 점에서 동일하지만 호출에 차이가 있다.
위 예시코드에서 함수 선언문으로 생성된 foo는 호출할 수 있으나 함수 리터럴 표현식으로 생성된 bar는 호출할 수 없다.

앞서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자라고 했으므로, 함수 몸체 외부에서는 함수 이름으로 함수를 참조 할 수 없다. 다시 말해, **_함수 몸체 외부에서 함수 이름으로 함수를 호출 할 수 없다._** 따라서 위 예시 코드의 bar 함수는 호출할 수 없다.

그런데 `foo`는 식별자 `foo`를 선언한 적이 없는데 무엇일까? 이는
자바스크립트 엔진이 암묵적으로 생성한 식별자이다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 참조할 수 없어 호출할 수도 없으므로 **자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 및 함수 객체를 할당한다.**

지금까지의 함수 선언문을 의사 코드로 표현하면 다음과 같다.

```JavaScript
var add = funcion add(x , y) {
    return x + y ;
};

console.log (add(2,5)); //7
```

함수는 함수 이름으로 호출하는 것이 아닌, 함수 객체를 가리키는 식별자로 호출함을 기억하자.

---

#### 함수 표현식

<br>

<p align="center">
<img src="./function_exp.jpg" 
    width="1000px;"
   </p>

---

#### 함수 생성 시점과 함수 호이스팅

   <br>

<p align="center">
<img src="./function_gene.jpg" 
    width="1000px;"
   </p>

---

#### Function 생성자 함수

<br>

```JavaScript
var add = new Function ('x' ,'y' 'return x + y');
console.log(add(2,5)); //7
```

js에서 함수를 만드는 일반적인 방법 - 함수 선언문 / 함수 표현식 사용

-> new function 사용 시, 함수의 매개변수 이름( `'x'` , `'y'`) 과 함수의 몸체(`'var add = new Function ('x','y', 'return x + y');`)를 문자열로 전달해서 동적으로 함수 생성 가능

위 예시코드는 아래와 같은 함수 선언문과 동일한 역할을 함.

```JavaScript
function add(x, y) {
    return x + y;
}
```

**_일반적인 함수 생성 방법보다 느려서 특수 상황이 아니면 잘 사용되지 않음_**

---

#### 화살표 함수

<br>

화살표 함수는 function 키워드 대신 화살표 `=>` 를 사용해 좀 더 간략한 방법으로 함수 선언 가능. ( 항상 익명 함수로 정의)

```JavaScript
const add = (x ,y) => x + y;
console.log(add(2,5)); //7
```

---

### 함수 호출

#### 매개변수와 인수

<br>

함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우에는,

매개변수를 통해 인수를 전달한다.

인수는 **값으로 평가될 수 있는 표현식이어야** 한다. 또한 그 개수와 타입에 제한이 없다.

```JavaScript
//함수 선언문
function add(x,y) {
    return x + y;
}

//함수 호출
//인수 1과 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1,2);
```

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급되며, 함수 호출 시 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 undefined로 초기회된 이후 인수가 순서대로 할당된다.

(add가 실행되기 전에, js엔진은 이 함수의 x,y를 위한 공간을 메모리에 자동으로 만드는데, 이때 변수들에는 일단 undefined가 할당됨. 이후 함수 호출시 전달한 인수 1,2가 변수들에 할당. )

```JavaScript
function add(x,y){
    console.log(x,y);// 2 5
    return x + y;

}

add(2,5);

// add함수의 매개변수 x,y는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x,y); //ReferenceError: x is not defined
```

위 예제에서 볼 수 있다시피, 매개변수는 함수 몸체 내부에서만 참조할 수 있고, 함수 몸체 외부에서는 참조할 수 없다.

```JavaScript
function add(x,y){
    return x + y ;

}

console.log(add(2)); //NaN
```

위 예제에서 필요한 인수는 두개인데 하나만 할당되었다. 따라서 매개변수 y는 undefined로 초기화된 상태 그대로다. 따라서 함수 몸체의 문 x + y 는 2 + undefined 와 같으므로 NaN이 반환된다.

만일, 매개변수보다 인수가 더많은 경우 초과된 인수는 무시된다.
(그냥 버려지는 것은 아니고, 암묵적으로 argument 객체의 프로퍼티로 보관된다.)

---

#### 인수 확인

```JavaScript

```
